using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace DasMulli.DataBuilderGenerator
{
    [Generator]
    public class DataBuilderGenerator : ISourceGenerator
    {
        private static readonly DiagnosticDescriptor GeneratorOnAbstractDiagnostic = new DiagnosticDescriptor("DBG001", "Cannot generate data builder for abstract class", "Cannot generate data builder for abstract class {0}", "DataBuilderGenerator", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor GeneratorOnPartialDiagnostic = new DiagnosticDescriptor("DBG002", "Cannot generate data builder for partial class", "Do not mark class {0} as partial in order to generate data builders for it (currently unsupported and may lead to undefined results)", "DataBuilderGenerator", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor CannotInferBuilderPropertyFromArgumentDiagnostic = new DiagnosticDescriptor("DBG003", "Cannot infer property name to use for constructor parameter (using constructor with most parameters)", "Mark class {0} as partial in order to generate data builders for it", "DataBuilderGenerator", DiagnosticSeverity.Error, true);

        /// <summary>
        /// A "generated by tool" comment string with environment/os-normalized newlines.
        /// </summary>
        public static readonly string GeneratedByDataBuilderGeneratorPreamble = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the data builder generator tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
".Replace("\r\n", "\n").Replace("\n", Environment.NewLine); // normalize regardless of git checkout policy

        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var cancellationToken = context.CancellationToken;

            var generateDataBuilderAttributeType =
                context.Compilation.GetTypeByMetadataName("DasMulli.DataBuilderGenerator.GenerateDataBuilderAttribute");
            if (generateDataBuilderAttributeType is null)
            {
                // Data builder generators are not used by the project being compiled
                return;
            }

            var builders = DetermineBuildersToGenerate(context, generateDataBuilderAttributeType);

            var compilationUnits = GenerateBuilders(context, builders, cancellationToken);

            foreach (var (name, compilationUnit) in compilationUnits)
            {
                context.AddSource(name, compilationUnit.GetText(Encoding.UTF8));
            }
        }

        private static Dictionary<string, BuilderToGenerate> DetermineBuildersToGenerate(GeneratorExecutionContext context, INamedTypeSymbol generateDataBuilderAttributeType)
        {
            var builders = new Dictionary<string, BuilderToGenerate>();

            foreach (var inputDocument in context.Compilation.SyntaxTrees)
            {
                context.CancellationToken.ThrowIfCancellationRequested();

                var typeNodes = inputDocument.GetRoot()
                    .DescendantNodesAndSelf(n =>
                        n is CompilationUnitSyntax || n is NamespaceDeclarationSyntax || n is TypeDeclarationSyntax)
                    .OfType<TypeDeclarationSyntax>();

                var semanticModel = context.Compilation.GetSemanticModel(inputDocument);

                foreach (var typeNode in typeNodes)
                {
                    if (!typeNode.AttributeLists.ContainsAttributeType(semanticModel, generateDataBuilderAttributeType,
                        exactMatch: true))
                    {
                        continue;
                    }

                    var typeSymbol = semanticModel.GetDeclaredSymbol(typeNode);

                    if (typeSymbol == null)
                    {
                        continue;
                    }

                    var generationBlocked = false;

                    if (typeSymbol.IsAbstract)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(GeneratorOnAbstractDiagnostic, typeSymbol.Locations.First(),
                            typeSymbol.Name));
                        generationBlocked = true;
                    }

                    if (typeNode.Modifiers.Any(m => m.Kind() == SyntaxKind.PartialKeyword))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(GeneratorOnPartialDiagnostic, typeNode.GetLocation(),
                            typeSymbol.Name));
                        generationBlocked = true;
                    }

                    if (generationBlocked)
                    {
                        continue;
                    }

                    string typeFullMetadataName = typeSymbol.GetFullMetadataName();
                    if (!builders.TryGetValue(typeFullMetadataName, out var builder))
                    {
                        builder = new BuilderToGenerate(
                            typeSymbol.ContainingNamespace?.GetFullMetadataName(),
                            typeSymbol.Name,
                            typeNode,
                            typeSymbol.DeclaredAccessibility);

                        IMethodSymbol? constructorToUse = null;

                        foreach (var typeSymbolConstructor in typeSymbol.Constructors)
                        {
                            if (typeSymbolConstructor.IsStatic)
                            {
                                continue;
                            }

                            if (typeSymbolConstructor.Parameters.Length > (constructorToUse?.Parameters.Length ?? 0))
                            {
                                constructorToUse = typeSymbolConstructor;
                            }
                        }

                        builder.ConstructorToUse = constructorToUse;

                        builders.Add(typeFullMetadataName, builder);
                    }

                    builder.Properties.AddRange(
                        typeSymbol
                            .GetMembers()
                            .Concat(typeSymbol.GetBaseTypes().SelectMany(t => t.GetMembers()))
                            .OfType<IPropertySymbol>()
                            .Where(m => m.DeclaredAccessibility == Accessibility.Public && !m.IsReadOnly && !m.IsIndexer && !m.IsStatic)
                            .Select(property => new PropertyToGenerate(
                                $"_{property.Name.Substring(0, 1).ToLower()}{property.Name.Substring(1)}",
                                property.Name,
                                property.Type,
                                DetermineNullability(semanticModel, property)))
                    );
                }
            }

            return builders;
        }

        private static bool DetermineNullability(SemanticModel semanticModel, IPropertySymbol propertySymbol)
        {
            if (propertySymbol.Type.IsValueType)
            {
                return propertySymbol.Type.IsNullable();
            }

            var nullableContext = semanticModel.GetNullableContext(propertySymbol.Locations[0].SourceSpan.Start);
            if (nullableContext.AnnotationsEnabled())
            {
                return propertySymbol.DeclaringSyntaxReferences.Length != 0
                       && (propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax)?.Type
                       is NullableTypeSyntax;
            }
            return false;
        }

        private static List<(string Name, CompilationUnitSyntax CompilationUnit)> GenerateBuilders(GeneratorExecutionContext context, Dictionary<string, BuilderToGenerate> builders, CancellationToken cancellationToken)
        {
            var compilationUnits = new List<(string Name, CompilationUnitSyntax CompilationUnit)>();
            foreach (var builder in builders.Values)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var builderClass = ClassDeclaration(builder.BuilderName)
                    .AddModifiers(builder.Accessibility.GetModifiers())
                    .AddModifiers(Token(SyntaxKind.PartialKeyword));

                // Add instance fields
                builderClass = builderClass
                    .WithMembers(new SyntaxList<MemberDeclarationSyntax>(
                        builder.Properties.Select(property =>
                            FieldDeclaration(
                                    VariableDeclaration(property.InternalRepresentationTypeSyntax)
                                        .AddVariables(VariableDeclarator(Identifier(property.FieldName)))
                                )
                                .AddModifiers(Token(SyntaxKind.PrivateKeyword))
                        )));

                // Add parameterless constructor
                builderClass = builderClass.AddMembers(
                    ConstructorDeclaration(builder.BuilderName)
                        .AddModifiers(Token(SyntaxKind.PublicKeyword))
                        .AddBodyStatements()
                );

                // Add constructor from other builder of the same type
                var otherBuilderIdentifier = Identifier("otherBuilder");
                builderClass = builderClass
                    .AddMembers(
                        ConstructorDeclaration(builder.BuilderName)
                            .AddParameterListParameters(Parameter(otherBuilderIdentifier)
                                .WithType(ParseTypeName(builder.BuilderName)))
                            .AddModifiers(Token(SyntaxKind.PublicKeyword))
                            .AddBodyStatements(
                                builder.Properties.Select(property =>
                                        (StatementSyntax)ExpressionStatement(AssignmentExpression(
                                            SyntaxKind.SimpleAssignmentExpression,
                                            IdentifierName(property.FieldName),
                                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                                IdentifierName(otherBuilderIdentifier), IdentifierName(property.FieldName))
                                        ))
                                    )
                                    .ToArray()
                            )
                    );

                // Add constructor from a pre-existing/built instance
                var existingInstanceIdentifier = Identifier("existingInstance");
                builderClass = builderClass
                    .AddMembers(
                        ConstructorDeclaration(builder.BuilderName)
                            .AddParameterListParameters(Parameter(existingInstanceIdentifier)
                                .WithType(ParseTypeName(builder.Name)))
                            .AddModifiers(Token(SyntaxKind.PublicKeyword))
                            .AddBodyStatements(
                                builder.Properties.Select(property =>
                                        (StatementSyntax)ExpressionStatement(AssignmentExpression(
                                            SyntaxKind.SimpleAssignmentExpression,
                                            IdentifierName(property.FieldName),
                                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                                IdentifierName(existingInstanceIdentifier), IdentifierName(property.PropertyName))
                                        ))
                                    )
                                    .ToArray()
                            )
                    );

                builderClass = AddMutationMethods(builder, builderClass);

                if (!TryAddBuildMethod(context, builder, ref builderClass))
                {
                    continue;
                }

                var originalCompilationUnit = builder.TypeNode.Ancestors().OfType<CompilationUnitSyntax>().FirstOrDefault();
                if (originalCompilationUnit is null)
                {
                    continue;
                }

                var originalNamespaceDeclaration = builder.TypeNode.Ancestors().OfType<NamespaceDeclarationSyntax>().FirstOrDefault();

                var declaration = originalNamespaceDeclaration is null
                    ? (MemberDeclarationSyntax)builderClass
                    : NamespaceDeclaration(
                        originalNamespaceDeclaration.Name,
                        originalNamespaceDeclaration.Externs,
                        originalNamespaceDeclaration.Usings,
                        new SyntaxList<MemberDeclarationSyntax>(builderClass));

                var compilationUnit = CompilationUnit()
                    .WithExterns(originalCompilationUnit.Externs)
                    .WithUsings(originalCompilationUnit.Usings)
                    .AddMembers(declaration)
                    .WithLeadingTrivia(Comment(GeneratedByDataBuilderGeneratorPreamble), Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                    .WithTrailingTrivia(CarriageReturnLineFeed)
                    .NormalizeWhitespace();

                compilationUnits.Add((builder.BuilderName + ".cs", compilationUnit));
            }

            return compilationUnits;
        }

        private static ClassDeclarationSyntax AddMutationMethods(BuilderToGenerate builder, ClassDeclarationSyntax builderClass)
        {
            foreach (var property in builder.Properties)
            {
                var lowerCamelParameterName = property.PropertyName.Substring(0, 1).ToLowerInvariant() + property.PropertyName.Substring(1);
                var upperCamelParameterName = property.PropertyName.Substring(0, 1).ToUpperInvariant() + property.PropertyName.Substring(1);

                var localBuilderIdentifier = Identifier("mutatedBuilder");
                builderClass = builderClass.AddMembers(
                    MethodDeclaration(builder.BuilderTypeSyntax, "With" + upperCamelParameterName)
                        .AddModifiers(Token(SyntaxKind.PublicKeyword))
                        .AddParameterListParameters(Parameter(Identifier(lowerCamelParameterName)).WithType(property.TypeSyntax))
                        .AddBodyStatements(
                            LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
                                .AddVariables(VariableDeclarator(localBuilderIdentifier)
                                    .WithInitializer(EqualsValueClause(ObjectCreationExpression(builder.BuilderTypeSyntax)
                                        .AddArgumentListArguments(Argument(ThisExpression())))))),
                            ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName(localBuilderIdentifier), IdentifierName(property.FieldName)),
                                IdentifierName(lowerCamelParameterName))),
                            ReturnStatement(IdentifierName(localBuilderIdentifier))
                        )
                );

                if (property.IsNullable || property.TypeSyntax is NullableTypeSyntax)
                {
                    builderClass = builderClass.AddMembers(
                        MethodDeclaration(builder.BuilderTypeSyntax, "Without" + upperCamelParameterName)
                            .AddModifiers(Token(SyntaxKind.PublicKeyword))
                            .AddBodyStatements(
                                LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
                                    .AddVariables(VariableDeclarator(localBuilderIdentifier)
                                        .WithInitializer(EqualsValueClause(ObjectCreationExpression(builder.BuilderTypeSyntax)
                                            .AddArgumentListArguments(Argument(ThisExpression())))))),
                                ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                        IdentifierName(localBuilderIdentifier), IdentifierName(property.FieldName)),
                                    LiteralExpression(SyntaxKind.NullLiteralExpression))),
                                ReturnStatement(IdentifierName(localBuilderIdentifier))
                            )
                    );
                }
            }

            return builderClass;
        }

        private static bool TryAddBuildMethod(GeneratorExecutionContext context, BuilderToGenerate builder, ref ClassDeclarationSyntax builderClass)
        {
            var objectType = ParseTypeName(builder.Name);
            var buildMethodStatements = new List<StatementSyntax>();

            var creationExpression = ObjectCreationExpression(objectType);
            var propertiesSetViaConstructor = new List<PropertyToGenerate>();

            if (builder.ConstructorToUse is { } constructorToUse)
            {
                var arguments = new ArgumentSyntax[constructorToUse.Parameters.Length];
                var blocked = false;
                for (var i = 0; i < constructorToUse.Parameters.Length; i++)
                {
                    var parameterName = constructorToUse.Parameters[i].Name;
                    var matchingProperty = builder.Properties.FirstOrDefault(p =>
                        p.PropertyName.Equals(parameterName, StringComparison.OrdinalIgnoreCase));
                    if (matchingProperty == null)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(CannotInferBuilderPropertyFromArgumentDiagnostic,
                            constructorToUse.Parameters[i].Locations[0]));
                        blocked = true;
                    }
                    else
                    {
                        arguments[i] = Argument(PropertyAccessAndDefaultingExpression(matchingProperty));
                        propertiesSetViaConstructor.Add(matchingProperty);
                    }

                    foreach (var property in propertiesSetViaConstructor)
                    {
                        if (property.IsReferenceType && !property.IsNullable)
                        {
                            var throwStatement = ThrowStatement(ObjectCreationExpression(ParseTypeName("System.InvalidOperationException"))
                                .AddArgumentListArguments(Argument(LiteralExpression(SyntaxKind.StringLiteralExpression,
                                    Literal($"No value present for required property '{property.PropertyName}'.")))));
                            buildMethodStatements.Add(IfStatement(NullCheck(IdentifierName(property.FieldName)), throwStatement));
                        }
                    }
                }

                if (blocked)
                {
                    return false;
                }

                creationExpression = creationExpression.AddArgumentListArguments(arguments);
            }
            else
            {
                creationExpression = creationExpression.WithArgumentList(ArgumentList());
            }

            var buildingInstanceIdentifier = Identifier("instance");
            buildMethodStatements.Add(LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
                .AddVariables(VariableDeclarator(buildingInstanceIdentifier)
                    .WithInitializer(EqualsValueClause(creationExpression)))));

            buildMethodStatements.AddRange(builder.Properties.Except(propertiesSetViaConstructor).Select(property =>
                (StatementSyntax)IfStatement(
                     PrefixUnaryExpression(SyntaxKind.LogicalNotExpression, ParenthesizedExpression(NullCheck(IdentifierName(property.FieldName)))),
                     ExpressionStatement(
                        AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName(buildingInstanceIdentifier),
                                IdentifierName(property.PropertyName)),
                            PropertyAccessUnwrappingNullables(property))))));

            buildMethodStatements.Add(ReturnStatement(IdentifierName(buildingInstanceIdentifier)));

            builderClass = builderClass.AddMembers(
                MethodDeclaration(objectType, "Build")
                    .AddModifiers(Token(SyntaxKind.PublicKeyword))
                    .WithBody(Block(buildMethodStatements)));

            return true;
        }

        private static ExpressionSyntax NullCheck(ExpressionSyntax expressionToCheck)
            => IsPatternExpression(expressionToCheck, ConstantPattern(LiteralExpression(SyntaxKind.NullLiteralExpression)));

        private static ExpressionSyntax PropertyAccessAndDefaultingExpression(PropertyToGenerate property)
            => property.IsReferenceType
                ? (ExpressionSyntax)IdentifierName(property.FieldName)
                : BinaryExpression(SyntaxKind.CoalesceExpression, IdentifierName(property.FieldName), SyntaxFactory.DefaultExpression(property.TypeSyntax));

        private static ExpressionSyntax PropertyAccessUnwrappingNullables(PropertyToGenerate property)
            => property.IsReferenceType
                ? (ExpressionSyntax)IdentifierName(property.FieldName)
                : MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(property.FieldName), IdentifierName("Value"));

        private class BuilderToGenerate
        {
            public string? Namespace { get; }

            public string Name { get; }

            public string BuilderName { get; }

            public TypeSyntax BuilderTypeSyntax { get; }

            public TypeDeclarationSyntax TypeNode { get; }

            public Accessibility Accessibility { get; }

            public IMethodSymbol? ConstructorToUse { get; set; }

            public List<PropertyToGenerate> Properties { get; } = new List<PropertyToGenerate>();

            public BuilderToGenerate(string? @namespace, string name, TypeDeclarationSyntax typeNode, Accessibility accessibility)
            {
                Namespace = @namespace;
                Name = name;
                TypeNode = typeNode;
                BuilderName = name + "Builder";
                Accessibility = accessibility;
                BuilderTypeSyntax = ParseTypeName(BuilderName);
            }
        }

        private class PropertyToGenerate
        {
            public string FieldName { get; }

            public string PropertyName { get; }

            public ITypeSymbol TypeSymbol { get; }

            public TypeSyntax TypeSyntax { get; }

            public TypeSyntax InternalRepresentationTypeSyntax { get; }

            public string TypeFullMetadataName { get; }

            public bool IsNullable { get; }

            public bool IsReferenceType => TypeSymbol.IsReferenceType;

            public PropertyToGenerate(string fieldName, string propertyName, ITypeSymbol typeSymbol, bool isNullable)
            {
                FieldName = fieldName;
                PropertyName = propertyName;
                TypeSymbol = typeSymbol;
                var typeSyntax = TypeSyntax = ParseTypeName(typeSymbol.ToDisplayString());
                TypeFullMetadataName = typeSymbol.GetFullMetadataName();
                IsNullable = isNullable;
                InternalRepresentationTypeSyntax = !(typeSyntax is NullableTypeSyntax)
                    ? NullableType(typeSyntax)
                    : typeSyntax;
            }
        }
    }
}
